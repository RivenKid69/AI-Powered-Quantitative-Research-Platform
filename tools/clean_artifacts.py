"""Centralized cleanup for generated artifacts.

This script is used by the Makefile and CI to enforce the policy that no
generated files are kept in git and that `make clean` returns a pristine tree.
It is intentionally conservative about what it deletes: only common build/test
outputs and files that include Cython generation markers are removed.
"""
from __future__ import annotations

import argparse
import shutil
from pathlib import Path
from typing import Iterable, Sequence


SKIP_DIR_PARTS = {".git", ".venv", "venv", "env"}

# Directories we always wipe if present
ROOT_DIR_TARGETS: tuple[Path, ...] = (
    Path("build"),
    Path("dist"),
    Path(".pytest_cache"),
    Path(".hypothesis"),
    Path("htmlcov"),
    Path("htmlcov_cme"),
    Path("cache"),
    Path("artifacts"),
    Path("logs"),
    Path("tensorboard_logs"),
    Path("tensorboard"),
    Path("pbt_checkpoints"),
    Path("data/cache"),
)

# Files to delete if present at repository root
ROOT_FILE_TARGETS: tuple[Path, ...] = (
    Path("build_hash_report.json"),
    Path("build_output.txt"),
    Path(".coverage"),
    Path("coverage.xml"),
)

# Globs to remove anywhere in the tree (excluding env/.git)
FILE_GLOBS: tuple[str, ...] = (
    "*.pyc",
    "*.pyo",
    "*.pyd",
    "*.so",
    "*.dylib",
    "*.dll",
    "*.pdb",
    "*.egg-info",
)

# Directory names that should be removed regardless of depth
DIR_GLOBS: tuple[str, ...] = (
    "__pycache__",
    ".mypy_cache",
    ".ruff_cache",
)


def is_cython_generated(path: Path) -> bool:
    """Detect whether a C/C++/header file was generated by Cython."""
    if path.suffix.lower() not in {".c", ".cpp", ".h"}:
        return False
    try:
        sample = path.read_text(encoding="utf-8", errors="ignore")[:2000]
    except OSError:
        return False
    return "Generated by Cython" in sample or "BEGIN: Cython Metadata" in sample


def should_skip(path: Path) -> bool:
    return any(part in SKIP_DIR_PARTS for part in path.parts)


def collect_generated(root: Path) -> list[Path]:
    """Return a sorted list of generated artifacts under root."""
    candidates: set[Path] = set()

    for target in ROOT_DIR_TARGETS:
        path = root / target
        if path.exists() and not should_skip(path):
            candidates.add(path)

    for target in ROOT_FILE_TARGETS:
        path = root / target
        if path.exists() and not should_skip(path):
            candidates.add(path)

    for pattern in FILE_GLOBS:
        for path in root.rglob(pattern):
            if should_skip(path):
                continue
            if path.is_file() or path.is_dir():
                candidates.add(path)

    for pattern in DIR_GLOBS:
        for path in root.rglob(pattern):
            if should_skip(path):
                continue
            if path.is_dir():
                candidates.add(path)

    for path in root.rglob("*"):
        if should_skip(path) or not path.is_file():
            continue
        if is_cython_generated(path):
            candidates.add(path)

    return sorted(candidates)


def remove_paths(paths: Iterable[Path]) -> list[Path]:
    removed: list[Path] = []
    for path in sorted(paths):
        try:
            if path.is_dir():
                shutil.rmtree(path, ignore_errors=True)
            else:
                path.unlink(missing_ok=True)
            removed.append(path)
        except OSError:
            # If deletion fails, keep going but do not mark as removed.
            continue
    return removed


def parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Remove build/test artifacts and Cython-generated files."
    )
    parser.add_argument(
        "--root",
        type=Path,
        default=Path.cwd(),
        help="Repository root to clean (defaults to cwd).",
    )
    parser.add_argument(
        "--check-only",
        action="store_true",
        help="Do not delete files; exit 1 if any generated artifacts are present.",
    )
    return parser.parse_args(argv)


def main(argv: Sequence[str] | None = None) -> int:
    args = parse_args(argv)
    root: Path = args.root.resolve()

    generated = collect_generated(root)
    if args.check_only:
        if generated:
            print("Generated artifacts present:")
            for path in generated:
                print(f" - {path.relative_to(root)}")
            return 1
        print("No generated artifacts detected.")
        return 0

    removed = remove_paths(generated)
    if removed:
        print("Removed generated artifacts:")
        for path in removed:
            print(f" - {path.relative_to(root)}")
    else:
        print("No generated artifacts found to remove.")
    # Confirm that a second pass is clean
    if collect_generated(root):
        return 1
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
